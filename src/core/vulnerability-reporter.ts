import type { VulnerabilityReport, Vulnerability, Detection, ScraperSession } from '../types/index.js';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';

export class VulnerabilityReporter {
  private reportDir: string;

  constructor(reportDir: string = './reports') {
    this.reportDir = reportDir;
  }

  /**
   * Generate vulnerability report from session
   */
  async generateReport(
    session: ScraperSession,
    targetUrl: string,
    bypassSuccess: boolean
  ): Promise<VulnerabilityReport> {
    const vulnerabilities = this.analyzeDetections(session.detections);
    const detectionRate = this.calculateDetectionRate(session);

    const report: VulnerabilityReport = {
      sessionId: session.id,
      timestamp: Date.now(),
      targetUrl,
      vulnerabilities,
      bypassSuccess,
      detectionRate,
      recommendations: this.generateRecommendations(vulnerabilities),
    };

    await this.saveReport(report);

    return report;
  }

  /**
   * Analyze detections and convert to vulnerabilities
   */
  private analyzeDetections(detections: Detection[]): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Group detections by type
    const detectionsByType = new Map<string, Detection[]>();
    detections.forEach(d => {
      const existing = detectionsByType.get(d.type) || [];
      existing.push(d);
      detectionsByType.set(d.type, existing);
    });

    // Analyze each type
    detectionsByType.forEach((dets, type) => {
      switch (type) {
        case 'block':
          vulnerabilities.push({
            severity: 'high',
            category: 'Access Control',
            title: 'IP/Browser Blocking Detected',
            description: `The target detected and blocked ${dets.length} scraping attempts. This indicates active bot detection but may have blind spots.`,
            evidence: dets.map(d => d.details),
            recommendation: 'Implement more sophisticated bot detection including behavioral analysis and machine learning models.',
            cwe: 'CWE-799',
          });
          break;

        case 'captcha':
          vulnerabilities.push({
            severity: 'medium',
            category: 'Bot Detection',
            title: 'CAPTCHA Challenge Triggered',
            description: `CAPTCHA was presented ${dets.length} times, indicating the bot detection relies on CAPTCHA as primary defense.`,
            evidence: dets.map(d => d.details),
            recommendation: 'While CAPTCHAs help, consider adding fingerprinting and behavioral analysis for earlier detection.',
            cwe: 'CWE-799',
          });
          break;

        case 'challenge':
          vulnerabilities.push({
            severity: 'medium',
            category: 'Bot Detection',
            title: 'Bot Challenge Presented',
            description: `JavaScript challenges detected ${dets.length} times. May be bypassed with headless browser automation.`,
            evidence: dets.map(d => d.details),
            recommendation: 'Enhance challenges with device fingerprinting and TLS fingerprint validation.',
          });
          break;

        case 'rate-limit':
          vulnerabilities.push({
            severity: 'low',
            category: 'Rate Limiting',
            title: 'Rate Limiting Active',
            description: `Rate limits triggered ${dets.length} times. Good first line of defense but can be bypassed with distributed scraping.`,
            evidence: dets.map(d => d.details),
            recommendation: 'Implement distributed rate limiting with IP reputation scoring.',
          });
          break;

        case 'fingerprint':
          vulnerabilities.push({
            severity: 'info',
            category: 'Fingerprinting',
            title: 'Fingerprinting Attempt Detected',
            description: `Browser fingerprinting detected but was successfully spoofed ${dets.length} times.`,
            evidence: dets.map(d => d.details),
            recommendation: 'Combine multiple fingerprinting techniques and validate consistency across attributes.',
          });
          break;
      }
    });

    // If no detections, that's a critical vulnerability
    if (detections.length === 0) {
      vulnerabilities.push({
        severity: 'critical',
        category: 'Bot Detection',
        title: 'No Bot Detection Mechanisms Found',
        description: 'The scraper successfully accessed the target without triggering any bot detection. This indicates a complete lack of anti-bot protection.',
        evidence: ['No CAPTCHAs, challenges, or blocks encountered', 'All requests succeeded'],
        recommendation: 'Implement comprehensive bot detection including: rate limiting, fingerprinting, behavioral analysis, CAPTCHA for suspicious traffic, and WAF rules.',
        cwe: 'CWE-799',
        cvss: 9.0,
      });
    }

    return vulnerabilities;
  }

  /**
   * Calculate detection rate
   */
  private calculateDetectionRate(session: ScraperSession): number {
    if (session.requestCount === 0) return 0;

    const detectedRequests = session.detections.filter(
      d => d.type === 'block' || d.type === 'captcha' || d.type === 'challenge'
    ).length;

    return detectedRequests / session.requestCount;
  }

  /**
   * Generate recommendations based on vulnerabilities
   */
  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = [];

    const hasCritical = vulnerabilities.some(v => v.severity === 'critical');
    const hasHigh = vulnerabilities.some(v => v.severity === 'high');

    if (hasCritical) {
      recommendations.push('URGENT: Implement basic bot detection mechanisms immediately');
      recommendations.push('Deploy a Web Application Firewall (WAF) with bot protection');
      recommendations.push('Enable rate limiting on all API endpoints');
    }

    if (hasHigh || hasCritical) {
      recommendations.push('Implement browser fingerprinting (Canvas, WebGL, Audio)');
      recommendations.push('Deploy behavioral analysis to detect non-human patterns');
      recommendations.push('Use TLS fingerprinting to detect automation tools');
      recommendations.push('Implement progressive challenges (increase difficulty with suspicion)');
    }

    // Category-specific recommendations
    const categories = new Set(vulnerabilities.map(v => v.category));

    if (categories.has('Access Control')) {
      recommendations.push('Review and enhance IP blocking rules with reputation databases');
      recommendations.push('Implement device fingerprinting to track repeat offenders');
    }

    if (categories.has('Rate Limiting')) {
      recommendations.push('Implement sliding window rate limiting');
      recommendations.push('Add per-session and per-IP rate limits');
    }

    if (categories.has('Bot Detection')) {
      recommendations.push('Deploy machine learning models for bot detection');
      recommendations.push('Monitor for automation frameworks (Selenium, Playwright, Puppeteer)');
      recommendations.push('Implement honeypots and trap URLs to identify scrapers');
    }

    // General best practices
    recommendations.push('Enable detailed logging and monitoring for security events');
    recommendations.push('Regularly update and test bot detection rules');
    recommendations.push('Consider using a specialized bot management solution (Cloudflare, PerimeterX, DataDome)');

    return [...new Set(recommendations)]; // Remove duplicates
  }

  /**
   * Save report to file
   */
  private async saveReport(report: VulnerabilityReport): Promise<void> {
    await mkdir(this.reportDir, { recursive: true });

    const fileName = `vulnerability-report-${report.sessionId}-${Date.now()}.json`;
    const filePath = join(this.reportDir, fileName);

    await writeFile(filePath, JSON.stringify(report, null, 2));

    // Also save a markdown version
    const mdFileName = `vulnerability-report-${report.sessionId}-${Date.now()}.md`;
    const mdFilePath = join(this.reportDir, mdFileName);
    await writeFile(mdFilePath, this.generateMarkdownReport(report));
  }

  /**
   * Generate markdown version of report
   */
  private generateMarkdownReport(report: VulnerabilityReport): string {
    const date = new Date(report.timestamp).toISOString();

    let md = `# Security Vulnerability Assessment Report\n\n`;
    md += `**Target URL:** ${report.targetUrl}\n`;
    md += `**Session ID:** ${report.sessionId}\n`;
    md += `**Date:** ${date}\n`;
    md += `**Bypass Success:** ${report.bypassSuccess ? '✅ YES' : '❌ NO'}\n`;
    md += `**Detection Rate:** ${(report.detectionRate * 100).toFixed(2)}%\n\n`;

    md += `## Executive Summary\n\n`;
    const criticalCount = report.vulnerabilities.filter(v => v.severity === 'critical').length;
    const highCount = report.vulnerabilities.filter(v => v.severity === 'high').length;
    const mediumCount = report.vulnerabilities.filter(v => v.severity === 'medium').length;
    const lowCount = report.vulnerabilities.filter(v => v.severity === 'low').length;

    md += `This automated security assessment identified **${report.vulnerabilities.length}** vulnerability/vulnerabilities:\n\n`;
    if (criticalCount > 0) md += `- 🔴 **${criticalCount}** Critical\n`;
    if (highCount > 0) md += `- 🟠 **${highCount}** High\n`;
    if (mediumCount > 0) md += `- 🟡 **${mediumCount}** Medium\n`;
    if (lowCount > 0) md += `- 🔵 **${lowCount}** Low\n`;
    md += `\n`;

    if (report.bypassSuccess) {
      md += `⚠️ **The stealth scraper successfully bypassed your security measures.** This indicates significant gaps in your bot detection capabilities.\n\n`;
    } else {
      md += `✅ **The stealth scraper was detected and blocked.** Your security measures are functioning but may still have weaknesses.\n\n`;
    }

    md += `## Vulnerabilities\n\n`;
    report.vulnerabilities.forEach((vuln, idx) => {
      const severityEmoji = {
        critical: '🔴',
        high: '🟠',
        medium: '🟡',
        low: '🔵',
        info: 'ℹ️',
      }[vuln.severity];

      md += `### ${idx + 1}. ${vuln.title} ${severityEmoji}\n\n`;
      md += `**Severity:** ${vuln.severity.toUpperCase()}\n`;
      md += `**Category:** ${vuln.category}\n`;
      if (vuln.cwe) md += `**CWE:** ${vuln.cwe}\n`;
      if (vuln.cvss) md += `**CVSS Score:** ${vuln.cvss}\n`;
      md += `\n**Description:**\n${vuln.description}\n\n`;
      md += `**Evidence:**\n`;
      vuln.evidence.forEach(ev => {
        md += `- ${ev}\n`;
      });
      md += `\n**Recommendation:**\n${vuln.recommendation}\n\n`;
      md += `---\n\n`;
    });

    md += `## Recommendations\n\n`;
    report.recommendations.forEach((rec, idx) => {
      md += `${idx + 1}. ${rec}\n`;
    });

    md += `\n## Methodology\n\n`;
    md += `This assessment was conducted using an advanced stealth scraper with the following capabilities:\n\n`;
    md += `- Browser fingerprint randomization (Canvas, WebGL, Audio)\n`;
    md += `- Human-like behavior simulation\n`;
    md += `- TLS fingerprinting evasion\n`;
    md += `- WebRTC leak prevention\n`;
    md += `- Automation detection evasion\n`;
    md += `- Distributed request patterns\n\n`;

    md += `## Next Steps\n\n`;
    md += `1. Review and prioritize vulnerabilities based on severity\n`;
    md += `2. Implement recommended security controls\n`;
    md += `3. Re-test after implementing fixes\n`;
    md += `4. Establish continuous monitoring for bot activity\n`;
    md += `5. Consider deploying a comprehensive bot management solution\n\n`;

    md += `---\n`;
    md += `*Report generated by CoryStack Stealth Scraper - Security Testing Tool*\n`;

    return md;
  }

  /**
   * Generate summary of all reports
   */
  async generateSummary(reports: VulnerabilityReport[]): Promise<string> {
    const summary = {
      totalReports: reports.length,
      successfulBypasses: reports.filter(r => r.bypassSuccess).length,
      averageDetectionRate: reports.reduce((sum, r) => sum + r.detectionRate, 0) / reports.length,
      totalVulnerabilities: reports.reduce((sum, r) => sum + r.vulnerabilities.length, 0),
      vulnerabilitiesBySeverity: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0,
      },
    };

    reports.forEach(report => {
      report.vulnerabilities.forEach(vuln => {
        summary.vulnerabilitiesBySeverity[vuln.severity]++;
      });
    });

    return JSON.stringify(summary, null, 2);
  }
}
